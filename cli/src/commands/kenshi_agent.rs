//! Kenshi Agent release operations
//!
//! Release the kenshi-agent sidecar image with updates to all cluster manifests.
//! Handles both primary and secondary clusters in a single release.

use anyhow::{Context, Result};
use std::path::Path;
use tokio::process::Command as TokioCommand;
use tracing::info;

use crate::commands::push;

/// Release kenshi-agent: push image and update K8s manifests for all clusters
///
/// This handles the complete release workflow:
/// 1. Push image to GHCR with auto-tags (amd64-{sha}, amd64-latest)
/// 2. Update primary cluster kustomization.yaml images[] overlay
/// 3. Update secondary cluster kustomization.yaml images[] overlay
/// 4. Update primary cluster builder-pool agentImage field
/// 5. Update secondary cluster builder-pool agentImage field
/// 6. Commit and push to git
pub async fn release(
    image_path: String,
    registry: String,
    primary_kustomization: String,
    secondary_kustomization: String,
    primary_builder_pool: String,
    secondary_builder_pool: String,
    retries: u32,
    token: Option<String>,
) -> Result<()> {
    info!("ðŸš€ Starting kenshi-agent release");
    info!("   Image: {}", image_path);
    info!("   Registry: {}", registry);
    println!();

    // Step 1: Get git SHA for tagging
    let git_sha = push::get_git_sha().await?;
    let new_tag = format!("amd64-{}", git_sha);
    info!("ðŸ“‹ Release tag: {}", new_tag);
    println!();

    // Step 2: Push image to GHCR
    info!("â”â”â” Step 1/6: Push Image â”â”â”");
    push::execute(
        image_path,
        registry.clone(),
        vec![], // tags - will be generated by auto_tags
        true,   // auto_tags
        "amd64".to_string(),
        retries,
        token,
        false,         // push_attic
        String::new(), // attic_cache
        None,          // update_kustomization_path
        false,         // commit_kustomization
    )
    .await?;
    println!();

    // Step 3: Update primary cluster kustomization.yaml images[] overlay
    info!("â”â”â” Step 2/6: Update primary cluster kustomization â”â”â”");
    update_kustomization_image(&primary_kustomization, &registry, &new_tag).await?;
    println!();

    // Step 4: Update secondary cluster kustomization.yaml images[] overlay
    info!("â”â”â” Step 3/6: Update secondary cluster kustomization â”â”â”");
    update_kustomization_image(&secondary_kustomization, &registry, &new_tag).await?;
    println!();

    // Step 5: Update primary cluster builder-pool agentImage
    info!("â”â”â” Step 4/6: Update primary cluster builder-pool â”â”â”");
    update_builder_pool_agent_image(&primary_builder_pool, &registry, &new_tag).await?;
    println!();

    // Step 6: Update secondary cluster builder-pool agentImage
    info!("â”â”â” Step 5/6: Update secondary cluster builder-pool â”â”â”");
    update_builder_pool_agent_image(&secondary_builder_pool, &registry, &new_tag).await?;
    println!();

    // Step 7: Commit and push
    info!("â”â”â” Step 6/6: Commit and Push â”â”â”");
    commit_and_push_release(
        &[
            &primary_kustomization,
            &secondary_kustomization,
            &primary_builder_pool,
            &secondary_builder_pool,
        ],
        &new_tag,
    )
    .await?;

    println!();
    info!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    info!("â•‘  âœ… kenshi-agent release complete!                         â•‘");
    info!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();
    info!("Image: {}:{}", registry, new_tag);
    info!("Updated all clusters");
    info!("FluxCD will reconcile the changes automatically.");
    println!();

    Ok(())
}

/// Update kustomization.yaml images[] overlay for kenshi-agent
///
/// Finds the kenshi-agent image entry and updates the newTag.
/// Also updates AGENT_IMAGE env var if present in patches.
async fn update_kustomization_image(
    kustomization_path: &str,
    registry: &str,
    new_tag: &str,
) -> Result<()> {
    let path = Path::new(kustomization_path);
    if !path.exists() {
        anyhow::bail!("Kustomization file not found: {}", kustomization_path);
    }

    info!("ðŸ“ Updating: {}", kustomization_path);

    // Read content
    let content = tokio::fs::read_to_string(path)
        .await
        .context("Failed to read kustomization.yaml")?;

    let new_image = format!("{}:{}", registry, new_tag);
    let mut updated_images = false;
    let mut updated_env = false;
    let mut new_content = String::new();
    let mut in_kenshi_agent_image = false;

    for line in content.lines() {
        // Track if we're in the kenshi-agent image block
        if line.contains("name:") && line.contains("kenshi-agent") {
            in_kenshi_agent_image = true;
        }
        // Exit the image block when we hit another image entry
        if in_kenshi_agent_image
            && line.trim().starts_with("- name:")
            && !line.contains("kenshi-agent")
        {
            in_kenshi_agent_image = false;
        }

        // Update newTag within the kenshi-agent image block
        if in_kenshi_agent_image && line.contains("newTag:") {
            let indent = line.len() - line.trim_start().len();
            let indent_str: String = line.chars().take(indent).collect();
            new_content.push_str(&format!("{}newTag: {}\n", indent_str, new_tag));
            updated_images = true;
            info!("   Updated images[] newTag to: {}", new_tag);
        }
        // Update AGENT_IMAGE env var reference if present
        else if line.contains("AGENT_IMAGE") && line.contains("kenshi-agent:") {
            // Replace the image:tag pattern
            let start_idx = line.find(registry).unwrap_or(0);
            if start_idx > 0 {
                let prefix = &line[..start_idx];
                let after_registry = &line[start_idx..];
                let tag_end = after_registry
                    .find(|c: char| c == '"' || c == '\'' || c == ' ' || c == '\n')
                    .unwrap_or(after_registry.len());
                let suffix = &after_registry[tag_end..];
                new_content.push_str(&format!("{}{}{}\n", prefix, new_image, suffix));
                updated_env = true;
                info!("   Updated AGENT_IMAGE env to: {}", new_image);
            } else {
                new_content.push_str(line);
                new_content.push('\n');
            }
        } else {
            new_content.push_str(line);
            new_content.push('\n');
        }
    }

    if !updated_images && !updated_env {
        anyhow::bail!(
            "No kenshi-agent entry found in images[] or AGENT_IMAGE in {}",
            kustomization_path
        );
    }

    // Write back
    let final_content = new_content.trim_end().to_string() + "\n";
    tokio::fs::write(path, &final_content)
        .await
        .context("Failed to write kustomization.yaml")?;

    info!("   âœ… Kustomization updated");
    Ok(())
}

/// Update builder-pool YAML agentImage field
///
/// Finds the agentImage field and updates it to the new tag.
async fn update_builder_pool_agent_image(
    builder_pool_path: &str,
    registry: &str,
    new_tag: &str,
) -> Result<()> {
    let path = Path::new(builder_pool_path);
    if !path.exists() {
        anyhow::bail!("Builder pool file not found: {}", builder_pool_path);
    }

    info!("ðŸ“ Updating: {}", builder_pool_path);

    // Read content
    let content = tokio::fs::read_to_string(path)
        .await
        .context("Failed to read builder-pool.yaml")?;

    let new_image = format!("{}:{}", registry, new_tag);
    let mut updated = false;
    let mut new_content = String::new();

    for line in content.lines() {
        // Update agentImage field
        if line.trim().starts_with("agentImage:") {
            let indent = line.len() - line.trim_start().len();
            let indent_str: String = line.chars().take(indent).collect();
            new_content.push_str(&format!("{}agentImage: {}\n", indent_str, new_image));
            updated = true;
            info!("   Updated agentImage to: {}", new_image);
        } else {
            new_content.push_str(line);
            new_content.push('\n');
        }
    }

    if !updated {
        anyhow::bail!("No agentImage field found in {}", builder_pool_path);
    }

    // Write back
    let final_content = new_content.trim_end().to_string() + "\n";
    tokio::fs::write(path, &final_content)
        .await
        .context("Failed to write builder-pool.yaml")?;

    info!("   âœ… Builder pool updated");
    Ok(())
}

/// Commit and push release changes for all modified files
async fn commit_and_push_release(files: &[&str], new_tag: &str) -> Result<()> {
    info!("ðŸ“¤ Committing release changes...");

    // Git add all files
    let mut add_args = vec!["add"];
    add_args.extend(files.iter().copied());

    let add_status = TokioCommand::new("git")
        .args(&add_args)
        .status()
        .await
        .context("Failed to stage files")?;

    if !add_status.success() {
        anyhow::bail!("Failed to stage release files");
    }

    // Check if there are changes to commit
    let diff_check = TokioCommand::new("git")
        .args(&["diff", "--cached", "--quiet"])
        .status()
        .await
        .context("Failed to check for changes")?;

    if diff_check.success() {
        info!("   No changes to commit (already at this version)");
        return Ok(());
    }

    // Commit
    let commit_msg = format!(
        "chore(release): Update kenshi-agent to {}\n\nUpdated target clusters",
        new_tag
    );

    let commit_status = TokioCommand::new("git")
        .args(&["commit", "-m", &commit_msg])
        .status()
        .await
        .context("Failed to commit")?;

    if !commit_status.success() {
        anyhow::bail!("Failed to commit release changes");
    }

    info!("   âœ… Changes committed");

    // Push
    info!("   Pushing to remote...");
    let push_status = TokioCommand::new("git")
        .args(&["push", "origin", "main"])
        .status()
        .await
        .context("Failed to push")?;

    if !push_status.success() {
        anyhow::bail!("Failed to push release to git");
    }

    info!("   âœ… Pushed to main");
    Ok(())
}
