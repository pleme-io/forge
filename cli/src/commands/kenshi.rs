//! Kenshi operator release operations
//!
//! Release the kenshi operator image with updates to all cluster manifests.
//! Handles both primary and secondary clusters in a single release.

use anyhow::{Context, Result};
use std::path::Path;
use tokio::process::Command as TokioCommand;
use tracing::info;

use crate::commands::push;

/// Release kenshi operator: push image and update K8s manifests for all clusters
///
/// This handles the complete release workflow:
/// 1. Push image to GHCR with auto-tags (amd64-{sha}, amd64-latest)
/// 2. Update primary cluster kustomization.yaml images[] overlay
/// 3. Update secondary cluster kustomization.yaml images[] overlay
/// 4. Commit and push to git
pub async fn release(
    image_path: String,
    registry: String,
    primary_kustomization: String,
    secondary_kustomization: String,
    retries: u32,
    token: Option<String>,
) -> Result<()> {
    info!("ðŸš€ Starting kenshi operator release");
    info!("   Image: {}", image_path);
    info!("   Registry: {}", registry);
    println!();

    // Step 1: Get git SHA for tagging
    let git_sha = push::get_git_sha().await?;
    let new_tag = format!("amd64-{}", git_sha);
    info!("ðŸ“‹ Release tag: {}", new_tag);
    println!();

    // Step 2: Push image to GHCR
    info!("â”â”â” Step 1/4: Push Image â”â”â”");
    push::execute(
        image_path,
        registry.clone(),
        vec![], // tags - will be generated by auto_tags
        true,   // auto_tags
        "amd64".to_string(),
        retries,
        token,
        false,         // push_attic
        String::new(), // attic_cache
        None,          // update_kustomization_path
        false,         // commit_kustomization
    )
    .await?;
    println!();

    // Step 3: Update primary cluster kustomization.yaml images[] overlay
    info!("â”â”â” Step 2/4: Update primary cluster kustomization â”â”â”");
    update_kustomization_image(&primary_kustomization, &registry, &new_tag).await?;
    println!();

    // Step 4: Update secondary cluster kustomization.yaml images[] overlay
    info!("â”â”â” Step 3/4: Update secondary cluster kustomization â”â”â”");
    update_kustomization_image(&secondary_kustomization, &registry, &new_tag).await?;
    println!();

    // Step 5: Commit and push
    info!("â”â”â” Step 4/4: Commit and Push â”â”â”");
    commit_and_push_release(&[&primary_kustomization, &secondary_kustomization], &new_tag).await?;

    println!();
    info!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    info!("â•‘  âœ… kenshi operator release complete!                      â•‘");
    info!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();
    info!("Image: {}:{}", registry, new_tag);
    info!("Updated all clusters");
    info!("FluxCD will reconcile the changes automatically.");
    println!();

    Ok(())
}

/// Update kustomization.yaml images[] overlay for kenshi
///
/// Finds the kenshi image entry and updates the newTag.
async fn update_kustomization_image(
    kustomization_path: &str,
    registry: &str,
    new_tag: &str,
) -> Result<()> {
    let path = Path::new(kustomization_path);
    if !path.exists() {
        anyhow::bail!("Kustomization file not found: {}", kustomization_path);
    }

    info!("ðŸ“ Updating: {}", kustomization_path);

    // Read content
    let content = tokio::fs::read_to_string(path)
        .await
        .context("Failed to read kustomization.yaml")?;

    let mut updated = false;
    let mut new_content = String::new();
    let mut in_kenshi_image = false;

    for line in content.lines() {
        // Track if we're in the kenshi image block (but not kenshi-agent)
        if line.contains("name:") && line.contains("kenshi") && !line.contains("kenshi-agent") {
            in_kenshi_image = true;
        }
        // Exit the image block when we hit another image entry
        if in_kenshi_image && line.trim().starts_with("- name:") && !line.contains(registry) {
            in_kenshi_image = false;
        }

        // Update newTag within the kenshi image block
        if in_kenshi_image && line.contains("newTag:") {
            let indent = line.len() - line.trim_start().len();
            let indent_str: String = line.chars().take(indent).collect();
            new_content.push_str(&format!("{}newTag: {}\n", indent_str, new_tag));
            updated = true;
            in_kenshi_image = false; // Done with this block
            info!("   Updated images[] newTag to: {}", new_tag);
        } else {
            new_content.push_str(line);
            new_content.push('\n');
        }
    }

    if !updated {
        anyhow::bail!(
            "No kenshi entry found in images[] in {}",
            kustomization_path
        );
    }

    // Write back
    let final_content = new_content.trim_end().to_string() + "\n";
    tokio::fs::write(path, &final_content)
        .await
        .context("Failed to write kustomization.yaml")?;

    info!("   âœ… Kustomization updated");
    Ok(())
}

/// Commit and push release changes for all modified files
async fn commit_and_push_release(files: &[&str], new_tag: &str) -> Result<()> {
    info!("ðŸ“¤ Committing release changes...");

    // Git add all files
    let mut add_args = vec!["add"];
    add_args.extend(files.iter().copied());

    let add_status = TokioCommand::new("git")
        .args(&add_args)
        .status()
        .await
        .context("Failed to stage files")?;

    if !add_status.success() {
        anyhow::bail!("Failed to stage release files");
    }

    // Check if there are changes to commit
    let diff_check = TokioCommand::new("git")
        .args(&["diff", "--cached", "--quiet"])
        .status()
        .await
        .context("Failed to check for changes")?;

    if diff_check.success() {
        info!("   No changes to commit (already at this version)");
        return Ok(());
    }

    // Commit
    let commit_msg = format!(
        "chore(release): Update kenshi operator to {}\n\nUpdated target clusters",
        new_tag
    );

    let commit_status = TokioCommand::new("git")
        .args(&["commit", "-m", &commit_msg])
        .status()
        .await
        .context("Failed to commit")?;

    if !commit_status.success() {
        anyhow::bail!("Failed to commit release changes");
    }

    info!("   âœ… Changes committed");

    // Push
    info!("   Pushing to remote...");
    let push_status = TokioCommand::new("git")
        .args(&["push", "origin", "main"])
        .status()
        .await
        .context("Failed to push")?;

    if !push_status.success() {
        anyhow::bail!("Failed to push release to git");
    }

    info!("   âœ… Pushed to main");
    Ok(())
}
